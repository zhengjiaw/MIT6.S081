diff --git a/kernel/defs.h b/kernel/defs.h
index 4b9bbc0..d3b1645 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -77,6 +77,7 @@ int             piperead(struct pipe*, uint64, int);
 int             pipewrite(struct pipe*, uint64, int);
 
 // printf.c
+void backtrace();
 void            printf(char*, ...);
 void            panic(char*) __attribute__((noreturn));
 void            printfinit(void);
diff --git a/kernel/printf.c b/kernel/printf.c
index e1347de..dac0c66 100644
--- a/kernel/printf.c
+++ b/kernel/printf.c
@@ -15,6 +15,17 @@
 #include "defs.h"
 #include "proc.h"
 
+void backtrace()
+{
+    printf("backtrace:\n");
+    uint64 fp = r_fp();
+    while(PGROUNDDOWN(fp) != PGROUNDUP(fp) ) {
+        printf("%p\n", *(uint64*)(fp - 8));
+        fp = *(uint64*)(fp - 16);
+    }
+    // printf("%p\n", fp);
+}
+
 volatile int panicked = 0;
 
 // lock to avoid interleaving concurrent printf's.
@@ -119,6 +130,7 @@ panic(char *s)
 {
   pr.locking = 0;
   printf("panic: ");
+//   backtrace();
   printf(s);
   printf("\n");
   panicked = 1; // freeze uart output from other CPUs
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 0aec003..0b43453 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -1,3 +1,10 @@
+static inline uint64
+r_fp()
+{
+  uint64 x;
+  asm volatile("mv %0, s0" : "=r" (x) );
+  return x;
+}
 // which hart (core) is this?
 static inline uint64
 r_mhartid()
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..9846b6b 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -60,6 +60,7 @@ sys_sleep(void)
 
   if(argint(0, &n) < 0)
     return -1;
+  backtrace(); // 不可以放到 acquire 后面，会通不过测试
   acquire(&tickslock);
   ticks0 = ticks;
   while(ticks - ticks0 < n){
