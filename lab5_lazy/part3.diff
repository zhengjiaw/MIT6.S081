diff --git a/.gdbinit.tmpl-riscv b/.gdbinit.tmpl-riscv
index 6a38a95..faff3cc 100644
--- a/.gdbinit.tmpl-riscv
+++ b/.gdbinit.tmpl-riscv
@@ -3,3 +3,4 @@ set architecture riscv:rv64
 target remote 127.0.0.1:1234
 symbol-file kernel/kernel
 set disassemble-next-line auto
+set riscv use-compressed-breakpoints yes
\ No newline at end of file
diff --git a/kernel/defs.h b/kernel/defs.h
index 4b9bbc0..aa2b2ae 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -140,6 +140,7 @@ int             fetchaddr(uint64, uint64*);
 void            syscall();
 
 // trap.c
+pte_t* handlePageFault(uint64 va, int );
 extern uint     ticks;
 void            trapinit(void);
 void            trapinithart(void);
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..16d3080 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -37,6 +37,17 @@ sys_wait(void)
     return -1;
   return wait(p);
 }
+static int
+growproc_lazy(int n)
+{
+  struct proc *p = myproc();
+//   printf("p->ze  %dsys_bark %d\n", p->sz, n);
+//   if(p->sz  > MAXVA - n) return -1;
+  if(n < 0)
+    p->sz = uvmdealloc(p->pagetable, p->sz, p->sz + n);
+  else p->sz += n;
+  return 0;
+}
 
 uint64
 sys_sbrk(void)
@@ -47,7 +58,7 @@ sys_sbrk(void)
   if(argint(0, &n) < 0)
     return -1;
   addr = myproc()->sz;
-  if(growproc(n) < 0)
+  if(growproc_lazy(n) < 0)
     return -1;
   return addr;
 }
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..18a3899 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -33,6 +33,8 @@ trapinithart(void)
 // handle an interrupt, exception, or system call from user space.
 // called from trampoline.S
 //
+pte_t *
+walk(pagetable_t pagetable, uint64 va, int alloc);
 void
 usertrap(void)
 {
@@ -67,12 +69,13 @@ usertrap(void)
     syscall();
   } else if((which_dev = devintr()) != 0){
     // ok
+  } else if(r_scause() == 15 || r_scause() == 13) {
+      handlePageFault(r_stval(), 1);
   } else {
     printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
     printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
     p->killed = 1;
   }
-
   if(p->killed)
     exit(-1);
 
@@ -82,7 +85,29 @@ usertrap(void)
 
   usertrapret();
 }
-
+pte_t *handlePageFault(uint64 va, int kill)
+{
+  // printf("page fault %p\n", va);
+  struct proc *p = myproc();
+  pte_t *pte;
+  if(va >= p->sz || va <= p->trapframe->sp )  {
+    if(kill) exit(-1);
+    return 0;
+  } else if((pte = walk(p->pagetable, va, 0)) == 0 ||(*pte & PTE_V) == 0) {
+    char* kp = (char*)kalloc();
+    if(kp == 0)  {
+        // printf("out of memory\n");
+        exit(-1);
+    } else {
+      memset(kp, 0, PGSIZE);
+      if(mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)kp, PTE_U | PTE_W | PTE_R) < 0) {
+        kfree(kp);
+        panic("handlePageFault");
+      }
+    }
+  }
+  return pte;
+}
 //
 // return to user space
 //
diff --git a/kernel/vm.c b/kernel/vm.c
index bccb405..b11a6c7 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -87,28 +87,20 @@ walk(pagetable_t pagetable, uint64 va, int alloc)
   }
   return &pagetable[PX(0, va)];
 }
-
 // Look up a virtual address, return the physical address,
 // or 0 if not mapped.
 // Can only be used to look up user pages.
 uint64
 walkaddr(pagetable_t pagetable, uint64 va)
 {
-  pte_t *pte;
-  uint64 pa;
-
   if(va >= MAXVA)
     return 0;
 
-  pte = walk(pagetable, va, 0);
-  if(pte == 0)
-    return 0;
-  if((*pte & PTE_V) == 0)
-    return 0;
-  if((*pte & PTE_U) == 0)
-    return 0;
-  pa = PTE2PA(*pte);
-  return pa;
+  pte_t *pte = walk(pagetable, va, 0);
+  if(pte == 0 || (*pte & PTE_V) == 0) 
+    pte = handlePageFault(va, 0);
+  if(pte == 0) return 0;
+  return PTE2PA(*pte);
 }
 
 // add a mapping to the kernel page table.
@@ -181,9 +173,9 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
 
   for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
     if((pte = walk(pagetable, a, 0)) == 0)
-      panic("uvmunmap: walk");
+      continue;
     if((*pte & PTE_V) == 0)
-      panic("uvmunmap: not mapped");
+      continue;
     if(PTE_FLAGS(*pte) == PTE_V)
       panic("uvmunmap: not a leaf");
     if(do_free){
@@ -283,6 +275,7 @@ freewalk(pagetable_t pagetable)
       freewalk((pagetable_t)child);
       pagetable[i] = 0;
     } else if(pte & PTE_V){
+      continue;
       panic("freewalk: leaf");
     }
   }
@@ -315,9 +308,9 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
 
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walk(old, i, 0)) == 0)
-      panic("uvmcopy: pte should exist");
+      continue;
     if((*pte & PTE_V) == 0)
-      panic("uvmcopy: page not present");
+      continue;
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
diff --git a/user/sh.c b/user/sh.c
index 83dd513..4817382 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -154,7 +154,9 @@ main(void)
       break;
     }
   }
-
+//   if(fork1() == 0)
+//       runcmd(parsecmd("usertests\n"));
+//   wait(0);
   // Read and run input commands.
   while(getcmd(buf, sizeof(buf)) >= 0){
     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
diff --git a/user/usertests.c b/user/usertests.c
index 7300574..1e31133 100644
--- a/user/usertests.c
+++ b/user/usertests.c
@@ -2588,7 +2588,6 @@ countfree()
     printf("pipe() failed in countfree()\n");
     exit(1);
   }
-  
   int pid = fork();
 
   if(pid < 0){
